package mil.af.rl.novelty;

import java.net.InetAddress;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.SortedSet;

import org.jgap.Allele;
import org.jgap.Chromosome;
import org.jgap.Genotype;
import org.jgap.event.GeneticEvent;
import org.jgap.event.GeneticEventListener;
import org.zeromq.ZMQ;
import org.zeromq.ZMQException;

import com.anji.neat.ConnectionAllele;
import com.anji.neat.NeuronAllele;
import com.anji.util.Configurable;
import com.anji.util.Properties;

import core.messages.ExperimentResults.Result;
import core.messages.ExperimentResults.ResultMessage;
import mil.af.rl.anji.NeatChromosomeUtility;

/**
 * Connect the information being generated by the evolutionary process with the
 * search party experiment running structure. This Listener is automatically started
 * when the mil.af.rl.NoveltyEvolver class is used to provide evolution.
 * 
 * @author sloscal1
 *
 */
//This class is instantiated in mil.af.rl.novelty.NoveltyEvolver, may be an option in future
public class SearchPartyEventListener implements Configurable,
GeneticEventListener {
	/** The port that the local core.party.Searcher is listening to */
	public static final String SEARCHER_PORT_KEY = "searcher-port";
	/** Get the prefix for the appropriate table where these results are supposed to be channeled */
	public static final String RESULT_TABLE_PREFIX_KEY = "result-table-prefix";
	/** Set to true to report neurons and connections in all chromosomes, false by default */
	public static final String REPORT_STRUCTURE_KEY = "sp-report-structure";

	/** Keep count of the generation on. */
	private int genOn = 0;
	/** true if the chromosome structure should be reported. */
	private boolean sendStructure = false;
	/** The socket to use for communication with the local Searcher */
	private ZMQ.Socket socket;
	/** The prefix to use in the SearchParty DB for all generated results */
	private String tablePrefix;

	@Override
	public void init(Properties props) throws Exception {
		//Make sure there is a table prefix or else the results will not be directed appropriately
		tablePrefix = props.getProperty(RESULT_TABLE_PREFIX_KEY);

		//Need to connect to the local searcher...
		ZMQ.Context context = null;
		try{
			context = ZMQ.context(1);
			socket = context.socket(ZMQ.PUSH);
			String localhost = InetAddress.getLocalHost().getHostAddress();
			socket.connect("tcp://"+localhost+":"+props.getProperty(SEARCHER_PORT_KEY));
		}catch(ZMQException e){
			e.printStackTrace();
		}
		sendStructure = props.getBooleanProperty(REPORT_STRUCTURE_KEY, false);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void geneticEventFired(GeneticEvent event) {
		if(GeneticEvent.GENOTYPE_EVOLVED_EVENT.equals(event.getEventName())){
			//Set up the transmission objects
			Result.Builder rb = Result.newBuilder();
			ResultMessage.Builder msgBuilder = ResultMessage.newBuilder();
			msgBuilder.setTableName(tablePrefix+"_RUN");
			msgBuilder.setTimestamp(new GregorianCalendar().getTimeInMillis());

			//Keep track of the generation that is being evaluated in this work
			Result generation = rb.setName("Generation")
					.setType(Result.Type.int32)
					.setValue(""+(genOn++)).build();

			//Want to write update for each of the chromosomes
			Genotype genotype = (Genotype)event.getSource();
			for(Chromosome chrom : (List<Chromosome>)genotype.getChromosomes()){
				msgBuilder.addReportedValue(generation);
				msgBuilder.addReportedValue(rb.setName("Fitness")
						.setType(Result.Type.int32)
						.setValue(""+chrom.getFitnessValue()).build());
				msgBuilder.addReportedValue(rb.setName("Primary_Parent_ID")
						.setType(Result.Type.int64)
						.setValue(""+chrom.getPrimaryParentId()).build());
				msgBuilder.addReportedValue(rb.setName("ID")
						.setType(Result.Type.int64)
						.setValue(""+chrom.getId()).build());
				if(sendStructure){
					String[] structure = getStructure(chrom);
					msgBuilder.addReportedValue(rb.setName("Neurons")
							.setType(Result.Type.string)
							.setValue(structure[0]).build());
					msgBuilder.addReportedValue(rb.setName("Conns")
							.setType(Result.Type.string)
							.setValue(structure[1]).build());
				}
				System.out.println(genOn+" "+chrom.getFitnessValue()+" "+chrom.getPrimaryParentId()+" "+chrom.getId());
				socket.send(msgBuilder.build().toByteArray(), ZMQ.NOBLOCK);
				msgBuilder.clearReportedValue();
			}
			System.out.println(tablePrefix+" "+genOn);
			System.out.println("#################PUSHED OUT A BUNCH OF RESULTS ####################");
		}
	}

	/**
	 * Encode the structure of a given chromosome into two strings, one for
	 * neurons and another for connections. Each neuron is encoded with "id=X,act=Y;" and
	 * each connection is encoded with "src=X,dest=Y,w=Z,id=Q;" where src and dest
	 * should be id's found in the neuron list if the NEAT algorithm is working
	 * correctly.
	 * 
	 * @param chrom must not be null
	 * @return [0] is the neuron string, [1] is the connection string.
	 */
	@SuppressWarnings("unchecked")
	private String[] getStructure(Chromosome chrom) {
		SortedSet<Allele> alleles = (SortedSet<Allele>)chrom.getAlleles();

		//Get the neurons
		List<NeuronAllele> neurons = (List<NeuronAllele>)NeatChromosomeUtility.getNeuronList(alleles);
		StringBuilder nsb = new StringBuilder();
		for(NeuronAllele neuron : neurons)
			nsb.append("id="+neuron.getInnovationId()+","
					+"act="+neuron.getActivationType().toString()+";");

		//Get the connections
		List<ConnectionAllele> conns = (List<ConnectionAllele>)NeatChromosomeUtility.getConnectionList(alleles);
		StringBuilder csb = new StringBuilder();
		for(ConnectionAllele conn : conns)
			csb.append("src="+conn.getSrcNeuronId()
					+",dest="+conn.getDestNeuronId()
					+",w="+conn.getWeight()
					+",id="+conn.getInnovationId()+";");

		return new String[]{nsb.toString(), csb.toString()};
	}
}
